const vmt_LS
   :LS.Print
   :LS.Init
   :LS.Start
   :LS.Search

func Main()
   t.0 = HeapAllocZ(12)
   [t.0] = :vmt_LS
   t.1 = 10
   if t.0 goto :null0
      Error("null pointer")
   null0:
   t.2 = [t.0]
   t.2 = [t.2+8]
   t.3 = call t.2(t.0 t.1)
   PrintIntS(t.3)
   ret

func LS.Start(this sz)
   t.0 = sz
   t.1 = [this]
   t.1 = [t.1+4]
   t.2 = call t.1(this t.0)
   aux01 = t.2
   t.3 = [this]
   t.3 = [t.3+0]
   t.4 = call t.3(this)
   aux02 = t.4
   PrintIntS(9999)
   t.5 = 8
   t.6 = [this]
   t.6 = [t.6+12]
   t.7 = call t.6(this t.5)
   PrintIntS(t.7)
   t.8 = 12
   t.9 = [this]
   t.9 = [t.9+12]
   t.10 = call t.9(this t.8)
   PrintIntS(t.10)
   t.11 = 17
   t.12 = [this]
   t.12 = [t.12+12]
   t.13 = call t.12(this t.11)
   PrintIntS(t.13)
   t.14 = 50
   t.15 = [this]
   t.15 = [t.15+12]
   t.16 = call t.15(this t.14)
   PrintIntS(t.16)
   t.17 = 55
   ret t.17

func LS.Print(this)
   j = 1
   while0_top:
   t.0 = LtS(j [this+8])
   if0 t.0 goto :while0_end
      t.1 = [[this+4]]
      t.1 = Lt(j t.1)
      if t.1 goto :bounds1
         Error("array index out of bounds")
      bounds1:
      t.1 = MulS(j 4)
      t.1 = Add(t.1 [this+4])
      PrintIntS([t.1+4])
      t.2 = Add(j 1)
      j = t.2
      goto :while0_top
   while0_end:
   t.3 = 0
   ret t.3

func LS.Search(this num)
   j = 1
   ls01 = 0
   ifound = 0
   while1_top:
   t.0 = LtS(j [this+8])
   if0 t.0 goto :while1_end
      t.1 = [[this+4]]
      t.1 = Lt(j t.1)
      if t.1 goto :bounds1
         Error("array index out of bounds")
      bounds1:
      t.1 = MulS(j 4)
      t.1 = Add(t.1 [this+4])
      aux01 = [t.1+4]
      t.2 = Add(num 1)
      aux02 = t.2
      t.3 = LtS(aux01 num)
      if0 t.3 goto :if0_else
         nt = 0
         goto :if0_end
      if0_else:
         t.4 = LtS(aux01 aux02)
         t.5 = Sub(1 t.4)
         if0 t.5 goto :if1_else
            nt = 0
            goto :if1_end
         if1_else:
            ls01 = 1
            ifound = 1
            j = [this+8]
         if1_end:
      if0_end:
      t.6 = Add(j 1)
      j = t.6
      goto :while1_top
   while1_end:
   t.7 = ifound
   ret t.7

func LS.Init(this sz)
   [this+8] = sz
   t.0 = call :AllocArray(sz)
   [this+4] = t.0
   j = 1
   t.1 = Add([this+8] 1)
   k = t.1
   while2_top:
   t.2 = LtS(j [this+8])
   if0 t.2 goto :while2_end
      t.3 = MulS(2 j)
      aux01 = t.3
      t.4 = Sub(k 3)
      aux02 = t.4
      t.5 = [this+4]
      if t.5 goto :null1
         Error("null pointer")
      null1:
      t.6 = [t.5]
      t.6 = Lt(j t.6)
      if t.6 goto :bounds2
         Error("array index out of bounds")
      bounds2:
      t.6 = MulS(j 4)
      t.6 = Add(t.6 t.5)
      t.7 = Add(aux01 aux02)
      [t.6+4] = t.7
      t.8 = Add(j 1)
      j = t.8
      t.9 = Sub(k 1)
      k = t.9
      goto :while2_top
   while2_end:
   t.10 = 0
   ret t.10

func AllocArray(size)
   bytes = MulS(size 4)
   bytes = Add(bytes 4)
   v = HeapAllocZ(bytes)
   [v] = size
   ret v

